<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java I/O详解</title>
    <url>/2020/04/26/Java-I-O%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="什么是IO流"><a href="#什么是IO流" class="headerlink" title="什么是IO流?"></a>什么是IO流?</h3><p>IO流正是所谓的文件输入输出流，这是Java提供给我们开发者遍历的操作文件的技术。</p>
<p>文件可认为是相关记录或放在一起的数据的集合 </p>
<h4 id="file类的常用方法"><a href="#file类的常用方法" class="headerlink" title="file类的常用方法"></a>file类的常用方法</h4><p>​        方法名称          说   明 </p>
<p>​        boolean exists( )       判断文件或目录是否存在</p>
<p>​        boolean isFile( )       判断是否是文件</p>
<p>​        boolean isDirectory( )    判断是否是目录 </p>
<p>​        String getPath( )       返回此对象表示的文件的相对路径名 </p>
<p>​        String getAbsolutePath( )   返回此对象表示的文件的绝对路径名</p>
<p>​        String getName( )      返回此对象表示的文件或目录的名称</p>
<p>​        boolean delete( )      删除此对象指定的文件或目录 </p>
<p>​        boolean createNewFile( )   创建名称的空文件，不创建文件夹</p>
<p>​        long  length()       返回文件的长度，单位为字节, 如果文 件不存在，则返回 0L </p>
<h3 id="Java的流"><a href="#Java的流" class="headerlink" title="Java的流"></a>Java的流</h3><p>​        流是指一连串流动的字符，是以先进先出的方式发送和接受数据的通道</p>
<p>​        输入流：InputStream 只能从中读取数据，而不能向其中写入数据</p>
<p>​        输出流：OutputStream只能向其中写入数据，而不能向其中读取数据</p>
<p>​        按照流向区分：</p>
<p>​            输入流：InputStream和Reader作为基类</p>
<p>​            输出流：OutputStream和Writer作为基类</p>
<p>​        按照处理数据单元划分：</p>
<p>​            字节流：字节输入流InputStream基类</p>
<p>​            字节输出流OutputStream基类</p>
<p>​        字符流：字符输入流Reader基类</p>
<p>​        字符输出流Writer基类</p>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>文本文件的读写：</p>
<pre><code>用FileInputStream和FileOutputStream读写文本 文件 </code></pre><p>​            用BufferedReader和BufferedWriter读写文本文 件</p>
<p>二进制文件的读写：</p>
<p>​            使用DataInputStream和DataOutputStream读写 二进制文件</p>
<h3 id="InputStream常用方法"><a href="#InputStream常用方法" class="headerlink" title="InputStream常用方法"></a>InputStream常用方法</h3><p>​         int read( )   int read(byte[] b)  int read(byte[] b,int off,int len) uvoid close( )   int available()  子类    FileInputStream</p>
<h3 id="常用的构造方法"><a href="#常用的构造方法" class="headerlink" title="常用的构造方法"></a>常用的构造方法</h3><pre><code>FileInputStream(File file)    FileInputStream(String name)</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>​        前两种构造方法在向文件写数据时将覆盖文件中原有的内容 </p>
<p>2、创建FileOutputStream实例时，如果相应的文件并不存在， 则会自动创建一个空的文件</p>
<h3 id="BufferedReader类特有的方法"><a href="#BufferedReader类特有的方法" class="headerlink" title="BufferedReader类特有的方法"></a>BufferedReader类特有的方法</h3><p>​        BufferedReader类是Reader类的子类 BufferedReader类带有缓冲区 按行读取内容的readLine()方法</p>
<p><img src="img/io.png" alt="io"></p>
<p>这个是IO流关系图，可以方便大家更好的理解IO流</p>
<h3 id="读取二进制文件"><a href="#读取二进制文件" class="headerlink" title="读取二进制文件"></a>读取二进制文件</h3><p>​        DataInputStream类</p>
<p>​         FileInputStream的子类 </p>
<p>​        与FileInputStream类结合使用读取二进制文件 </p>
<p>​         DataOutputStream类</p>
<p>​         FileOutputStream的子类 </p>
<p>​        与FileOutputStream类结合使用写二进制文件</p>
<h3 id="使用文件流的步骤"><a href="#使用文件流的步骤" class="headerlink" title="使用文件流的步骤"></a>使用文件流的步骤</h3><p>引入相关的类</p>
<p>创建输入流/l输出流对象</p>
<p> 读取/写入文本文件的数据</p>
<p>关闭相关的流对象</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/23/hello-world/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>如何快速的学习一门语言</title>
    <url>/2020/04/24/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>​        首先,在我们学习新东西的时候我们会产生好奇的心态，我们会问这个东西是干什么的? 我学这个东西有什么用？这些都是我们常见的一些问题，这里我们就用Java来举例，那么必须要知道的是我们为什么要学习Java，学习Java能给我带来什么好处，在学习一门新的语言之前，一定要了解自己为什么要学习它，了解清楚Java是干什么的，当你真正了解一门语言，你就会有清晰的目标。</p>
<h3 id="我该如何学习"><a href="#我该如何学习" class="headerlink" title="我该如何学习?"></a>我该如何学习?</h3><p>​     首先，这些学习方式以及经验都是我个人总结出来的，没有任何抄袭现象，很多东西都是有一些大众化，我尽量帮助各位小伙伴解疑答惑。</p>
<p>​        论学习，唯独一个字，从小学到大学一直没有变的一个字:”练”,只要练不死，就往死里练，其次就是要学会理解，在适当的时间专门钻研一个东西，当然是要钻研重要的东西。大家可能有的是自学，有的是报的培训班，但是这些都没有关系，我们都是在学习，不论在哪里。</p>
<h5 id="1-学习中遇到问题怎么办"><a href="#1-学习中遇到问题怎么办" class="headerlink" title="1.学习中遇到问题怎么办?"></a>1.学习中遇到问题怎么办?</h5><p>​    遇到问题不要慌，都是很正常的现象，在这里我可以跟大家分享一下我的经历，学过的小伙伴们也都知道，我们会碰到各式各样的bug，我自己也是一样，记得有一次，遇到了一个比较罕见的bug我就去网上查阅各种资料看各种源码，最后发现也就是少了一个标点符号，哈哈。其实这些并不是丢人，能够发现自己的问题并解决就是能力。就像我说的，遇到问题，可以先去百度或者更Google上搜索一下，如果搜索不出来，可以尝试的问一些大牛们，在培训班的小伙伴可以问一些老师，当然，初学者遇到问题呢也可以直接来找我，我随时欢迎你们，记住，在学习中遇到问题是很正常的，并且你也一定要希望遇到问题，解决了你就能提升。</p>
<h5 id="2-不知道学什么怎么办"><a href="#2-不知道学什么怎么办" class="headerlink" title="2.不知道学什么怎么办?"></a>2.不知道学什么怎么办?</h5><p>​        在互联网行业，技术发展随之即快，所以我们一定要不停的学习，什么技术火，学习什么技术，记住一句话，我们为什么要学习它？因为用的人多，所以我们要学习。无论你是在学习中还是在工作中，千万不要停止学习的脚步，你可以关注一些公众号以及一些关于IT的网站，这里面都会去详细讲解新技术发展如何，我们又改学习什么，当然把基础的学会，其他入门就很容易。具体还要学什么，就看公司要求了。我这里后续也会推出，学习路线以及群里的学习资料，对了,这里打个广告哈哈，这个是我自行创的群目前还没什么人，当然我也是希望你们能够加入和我一起进步:1081931475</p>
<h5 id="3-行业发展这么快-我赶不上怎么办"><a href="#3-行业发展这么快-我赶不上怎么办" class="headerlink" title="3.行业发展这么快?我赶不上怎么办?"></a>3.行业发展这么快?我赶不上怎么办?</h5><p>​        这个问题其实没有任何的确定回复性，因为现实就是如此，适者生存，如果你没有足够的能力在社会上立足，那么就会有人取代你。所以要想发展，必须做出努力。学习是我们最好的出路，无论到哪里，学习永远不会使人退步。</p>
<p>下面我为大家展现出第一个Java程序，当然第一个Java程序是非常简单的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJava</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信大佬们闭着眼睛都能写出来，但是初学者们，你们是否感觉到难了呢，因为你们没有接触过，当你们接触的时候你们就会豁然开朗，发现程序竟然是这么的好玩，很多事情开头都是一头污水 ，所以不要看着这么多英语，就放弃学习了，你自己选择的路一定要走下去。</p>
<h5 id="4-数学和英语不好能学会吗"><a href="#4-数学和英语不好能学会吗" class="headerlink" title="4.数学和英语不好能学会吗?"></a>4.数学和英语不好能学会吗?</h5><p>​        相信这个问题在很多初学者面前一直是一个大问题，我们没有好的数学和英语水平，但我可以告诉你们，我的数学和英语也是一塌糊度，但尽管没有这些做基垫，我照样可以学的很好，可能数学好的小伙伴学习编程可能会好理解一些，但这些相差并不大，只要我们肯努力，学习起来是不难的，我也可以告诉你们，英语不好学习编程也没有问题，因为学习编程还会使你的逻辑思维和英语大幅提升。</p>
<p>死亡鸡汤 总结一句话：数学只要会+ - * / % 就可以  英语的话不会也没事，只要了解就行了</p>
<p><strong>还有最重要的一点:学习编程后，一定要魔鬼训练自己的打字速度，这个非常重要，还要练习盲打。</strong></p>
<h5 id="5-学过之后忘了怎么办？"><a href="#5-学过之后忘了怎么办？" class="headerlink" title="5.学过之后忘了怎么办？"></a>5.学过之后忘了怎么办？</h5><p>​    这里我提出三个解决办法:</p>
<p>​            1.学习的同时自己要记笔记，写代码注释，并要有自己的总结，没事拿出来看看。也要归纳一个文档。</p>
<p>​            2.反复的复习，忘记哪个技术，回过头再看一遍。</p>
<p>​            3.写技术博客，就像我这样，把一些技术写到博客里，这样就算你电脑的文件没了，这个博客也不会没。</p>
<p>好了这期就到这里，可以看出来，这是我第一篇文章，我希望大家有什么意见尽管提出来，你们的意见是我提升的目标，谢谢大家！！！</p>
<p>​        </p>
]]></content>
  </entry>
  <entry>
    <title>Spring Boot注解大全</title>
    <url>/2020/04/29/Spring-Boot%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><strong>一、注解(annotations)列表</strong></p>
<p><strong>@SpringBootApplication</strong>：</p>
<p>包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。</p>
<p>其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。</p>
<p><strong>@Configuration</strong> 等同于spring的XML配置文件；使用Java代码可以检查类型安全。</p>
<p><strong>@EnableAutoConfiguration</strong> 自动配置。</p>
<p><strong>@ComponentScan</strong> 组件扫描，可自动发现和装配一些Bean。</p>
<p><strong>@Component</strong>可配合CommandLineRunner使用，在程序启动后执行一些基础任务。</p>
<p><strong>@RestController</strong>注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。</p>
<p><strong>@Autowired</strong>自动导入。</p>
<p><strong>@PathVariable</strong>获取参数。</p>
<p><strong>@JsonBackReference</strong>解决嵌套外链问题。</p>
<p><strong>@RepositoryRestResourcepublic</strong>配合spring-boot-starter-data-rest使用。</p>
<h1 id="二、注解-annotations-详解"><a href="#二、注解-annotations-详解" class="headerlink" title="二、注解(annotations)详解"></a>二、注解(annotations)详解</h1><p><strong>@SpringBootApplication</strong>：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myproject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// same as @Configuration @EnableAutoConfiguration @ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@ResponseBoby</strong>:表示该方法的返回结果直接写入到页面body当中，一般一部获取数据时使用、用于构建restful的api。</p>
<p>在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。</p>
<p>比如异步获取json数据，加上@responsebody后，会直接返回json数据。</p>
<p>该注解一般会配合@RequestMapping一起使用。示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(“/hello”)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>”hello”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Controller</strong>：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层）</p>
<p>一般这个注解在类中，通常方法需要配合注解@RequestMapping。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(“/cont”)</span><br><span class="line">publicclass ControllerTest &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoInfoService demoInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Map map)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DemoController.hello()"</span>);</span><br><span class="line">        map.put(<span class="string">"hello"</span>,<span class="string">"from TemplateController.helloHtml"</span>);</span><br><span class="line">        <span class="comment">//会使用hello.html或者hello.ftl模板进行渲染显示.</span></span><br><span class="line">        <span class="keyword">return</span><span class="string">"/hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@RestController</strong>：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kfit.demo.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(“/demoInfo2”)</span><br><span class="line">publicclass DemoController2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@RequestMapping</strong>：提供路由信息，负责URL到Controller中的具体函数的映射。</p>
<p><strong>@EnableAutoConfiguration</strong>：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。</p>
<p>例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。</p>
<p>你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。</p>
<p>如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。</p>
<p><strong>@ComponentScan</strong>：表示将该类自动发现扫描组件。</p>
<p>个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。</p>
<p>我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。</p>
<p>如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。</p>
<p><strong>@Configuration</strong>：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p>
<p><strong>@Import</strong>：用来导入其他配置类。</p>
<p><strong>@ImportResource</strong>：用来加载xml配置文件。</p>
<p><strong>@Autowired</strong>：自动导入依赖的bean</p>
<p><strong>@Service</strong>：一般用于修饰service层的组件</p>
<p><strong>@Repository</strong>：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p>
<p><strong>@Bean</strong>：用@Bean标注方法等价于XML中配置的bean。</p>
<p><strong>@Value</strong>：注入Spring boot application.properties配置的属性的值。示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@Value(value = “#&#123;message&#125;”)</span><br><span class="line"><span class="keyword">private</span> String message;</span><br></pre></td></tr></table></figure>

<p><strong>@Inject</strong>：等价于默认的@Autowired，只是没有required属性；</p>
<p><strong>@Component</strong>：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
<p><strong>@Bean</strong>：相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p>
<p><strong>@AutoWired</strong>：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。</p>
<p><strong>@Qualifier</strong>：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value = “demoInfoService”)</span><br><span class="line"><span class="keyword">private</span> DemoInfoService demoInfoService;</span><br></pre></td></tr></table></figure>

<p><strong>@Resource</strong>(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。</p>
<h1 id="三、springMVC相关注解"><a href="#三、springMVC相关注解" class="headerlink" title="三、springMVC相关注解"></a>三、springMVC相关注解</h1><p><strong>@RequestMapping</strong>：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。</p>
<p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。</p>
<p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：</p>
<p><strong>params</strong>:指定request中必须包含某些参数值是，才让该方法处理。</p>
<p><strong>headers</strong>:指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<p><strong>value</strong>:指定请求的实际地址，指定的地址可以是URI Template 模式</p>
<p><strong>method</strong>:指定请求的method类型， GET、POST、PUT、DELETE等</p>
<p><strong>consumes</strong>:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;</p>
<p><strong>produces</strong>:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p>
<p><strong>@RequestParam</strong>：用在方法的参数前面。<br>@RequestParam<br>String a =request.getParameter(“a”)。</p>
<p><strong>@PathVariable</strong>:路径变量。如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestMapping(“user/get/mac/&#123;macAddress&#125;”)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getByMacAddress</span><span class="params">(@PathVariable String macAddress)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数与大括号里的名字一样要相同。</p>
<h1 id="四、全局异常处理"><a href="#四、全局异常处理" class="headerlink" title="四、全局异常处理"></a>四、全局异常处理</h1><p><strong>@ControllerAdvice</strong>：包含@Component。可以被扫描到。统一处理异常。</p>
<p><strong>@ExceptionHandler</strong>（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p>
]]></content>
  </entry>
  <entry>
    <title>Ajax异步请求</title>
    <url>/2020/04/29/Ajax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>Ajax  </p>
<p>ajax:异步js和xml  异步刷新：如果网页中某一个地方需要修改，异步刷新可以使：只刷新该需要修改的地方</p>
<h5 id="一、使用原生JS方式实现ajax"><a href="#一、使用原生JS方式实现ajax" class="headerlink" title="一、使用原生JS方式实现ajax"></a>一、使用原生JS方式实现ajax</h5><pre><code>JS: XMLHttpRequest对象       </code></pre><p>​        XMLHttpRequest对象的方法：       </p>
<p>​        open(</p>
<p>​                方法名(提交方式get\post)，</p>
<p>​                服务器地址，true):与服务端建立连接·      </p>
<p>​                 send() :          </p>
<p>​                 get:send(null)           </p>
<p>​                post:send(参数值)       </p>
<p>​                setRequestHeader(header,value):           </p>
<p>​                get:不需要设置此方法          </p>
<p>​                post：需要设置                   </p>
<p>a.如果请求元素中包含了文件上传：setRequestHeader(“Content-Type”,”multiparty-form-data”)                   </p>
<p>b.不包含文件上传 ： setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”)             XMLHttpRequest对象的属性：readystate:请求状态   只有状态为4，才把响应执行完毕           </p>
<p> status:响应状态       只有200代表响应正常    </p>
<p> onreadystatechange:回调函数          </p>
<p> responseText：响应格式为String           </p>
<p> responseXML：响应为XML</p>
<h4 id="jquery-推荐"><a href="#jquery-推荐" class="headerlink" title="jquery:推荐"></a>jquery:推荐</h4><p>首先要使用ajax强推的就是利用jquery方式来实现，下面我为大家提供了几种方式</p>
<p>1.用ajax方法实现</p>
<p>$.ajax({     </p>
<p>​                utl:服务器地址，     </p>
<p>​                请求方式：get\post，     </p>
<p>​                data:请求数据，     </p>
<p>​                success:function(result,testStatus){</p>
<p>​                 },     error:function(xhr,erroeMessage,e){<br>​                         }   </p>
<p>​        }) </p>
<p>2.用get方法实现，比较简便，且只能处理get请求</p>
<p>​     $.get(     </p>
<p>​            服务器地址，     </p>
<p>​            请求数据，    </p>
<p>​           function(result){</p>
<p>​          }         </p>
<p>​        预期返回值类型（string\xml）   </p>
<p>​    )</p>
<p>3.利用post方法，同上 且只能处理post请求</p>
<p>$.post(     </p>
<p>​    服务器地址，     </p>
<p>​    请求数据，     </p>
<p>​    function(result){<br>​     }     </p>
<p>​    预期返回值类型（string\xml） </p>
<p>  )</p>
<p>4.利用load方式来实现，通过名字我们可以看出来这种方式是通过页面加载完毕后才可以执行，并且它需要依靠一个选择器，这个选择器可以是一个事件。</p>
<p>  $(“选择器”).load(    </p>
<p>​         服务器地址，      </p>
<p>​        请求数据，     </p>
<p>​         function(result){<br>​      }      预期返回值类型（string\xml）  </p>
<p> ) </p>
<p>​     load:将服务端的返回值 直接加载到$(“#xx”)所选择的元素中</p>
<p>5.这种方式只能处理JSON数据</p>
<p>  $.getJSON(       </p>
<p>​        服务器地址,       </p>
<p>​        JSON格式的请求数据，       </p>
<p>​        function(){}   </p>
<p>)</p>
]]></content>
  </entry>
</search>
