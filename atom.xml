<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-29T08:51:25.207Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>code J·T</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开发神器IDEA快捷键</title>
    <link href="http://yoursite.com/2020/04/29/%E5%BC%80%E5%8F%91%E7%A5%9E%E5%99%A8IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/04/29/%E5%BC%80%E5%8F%91%E7%A5%9E%E5%99%A8IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2020-04-29T08:51:13.000Z</published>
    <updated>2020-04-29T08:51:25.207Z</updated>
    
    <content type="html"><![CDATA[<p>Ctrl+Shift + Enter，语句完成<br>“！”，否定完成，输入表达式时按 “！”键<br>Ctrl+E，最近的文件<br>Ctrl+Shift+E，最近更改的文件<br>Shift+Click，可以关闭文件<br>Ctrl+[ OR ]，可以跑到大括号的开头与结尾<br>Ctrl+F12，可以显示当前文件的结构<br>Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择<br>Ctrl+N，可以快速打开类<br>Ctrl+Shift+N，可以快速打开文件<br>Alt+Q，可以看到当前方法的声明<br>Ctrl+P，可以显示参数信息<br>Ctrl+Shift+Insert，可以选择剪贴板内容并插入<br>Alt+Insert，可以生成构造器/Getter/Setter等<br>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义<br>Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch<br>Ctrl+Enter，导入包，自动修正<br>Ctrl+Alt+L，格式化代码<br>Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作<br>Ctrl+Alt+O，优化导入的类和包<br>Ctrl+R，替换文本<br>Ctrl+F，查找文本<br>Ctrl+Shift+Space，自动补全代码<br>Ctrl+空格，代码提示（与系统输入法快捷键冲突）<br>Ctrl+Shift+Alt+N，查找类中的方法或变量<br>Alt+Shift+C，最近的更改<br>Alt+Shift+Up/Down，上/下移一行<br>Shift+F6，重构 – 重命名<br>Ctrl+X，删除行<br>Ctrl+D，复制行<br>Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）<br>Ctrl+J，自动代码（例如：serr）<br>Ctrl+Alt+J，用动态模板环绕<br>Ctrl+H，显示类结构图（类的继承层次）<br>Ctrl+Q，显示注释文档<br>Alt+F1，查找代码所在位置<br>Alt+1，快速打开或隐藏工程面板<br>Ctrl+Alt+left/right，返回至上次浏览的位置<br>Alt+left/right，切换代码视图<br>Alt+Up/Down，在方法间快速移动定位<br>Ctrl+Shift+Up/Down，向上/下移动语句<br>F2 或 Shift+F2，高亮错误或警告快速定位<br>Tab，代码标签输入完成后，按 Tab，生成代码<br>Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失<br>Alt+F3，逐个往下查找相同文本，并高亮显示<br>Ctrl+Up/Down，光标中转到第一行或最后一行下<br>Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）<br>Ctrl+Alt+B，跳转到方法实现处<br>Ctrl+Shift+Backspace，跳转到上次编辑的地方<br>Ctrl+O，重写方法<br>Ctrl+Alt+Space，类名自动完成<br>Ctrl+Alt+Up/Down，快速跳转搜索结果<br>Ctrl+Shift+J，整合两行<br>Alt+F8，计算变量值<br>Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本<br>Ctrl+Alt+Shift+V，简单粘贴<br>Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口<br>F12，把焦点从编辑器移到最近使用的工具窗口<br>Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器<br>Ctrl+W，可以选择单词继而语句继而行继而函数<br>Ctrl+Shift+W，取消选择光标所在词<br>Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置<br>Ctrl+I，实现方法<br>Ctrl+Shift+U，大小写转化<br>Ctrl+Y，删除当前行</p><p>Shift+Enter，向下插入新行<br>psvm/sout，main/System.out.println(); Ctrl+J，查看更多<br>Ctrl+Shift+F，全局查找<br>Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找<br>Ctrl+Shift+S，高级搜索<br>Ctrl+U，转到父类<br>Ctrl+Alt+S，打开设置对话框<br>Alt+Shift+Inert，开启/关闭列选择模式<br>Ctrl+Alt+Shift+S，打开当前项目/模块属性<br>Ctrl+G，定位行<br>Alt+Home，跳转到导航栏<br>Ctrl+Enter，上插一行<br>Ctrl+Backspace，按单词删除<br>Ctrl+”+/-”，当前方法展开、折叠<br>Ctrl+Shift+”+/-”，全部展开、折叠<br>【调试部分、编译】<br>Ctrl+F2，停止<br>Alt+Shift+F9，选择 Debug<br>Alt+Shift+F10，选择 Run<br>Ctrl+Shift+F9，编译<br>Ctrl+Shift+F10，运行<br>Ctrl+Shift+F8，查看断点<br>F8，步过<br>F7，步入<br>Shift+F7，智能步入<br>Shift+F8，步出<br>Alt+Shift+F8，强制步过<br>Alt+Shift+F7，强制步入<br>Alt+F9，运行至光标处<br>Ctrl+Alt+F9，强制运行至光标处<br>F9，恢复程序<br>Alt+F10，定位到断点<br>Ctrl+F8，切换行断点<br>Ctrl+F9，生成项目<br>Alt+1，项目<br>Alt+2，收藏<br>Alt+6，TODO<br>Alt+7，结构<br>Ctrl+Shift+C，复制路径<br>Ctrl+Alt+Shift+C，复制引用，必须选择类名<br>Ctrl+Alt+Y，同步<br>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）<br>Shift+F12，还原默认布局<br>Ctrl+Shift+F12，隐藏/恢复所有窗口<br>Ctrl+F4，关闭<br>Ctrl+Shift+F4，关闭活动选项卡<br>Ctrl+Tab，转到下一个拆分器<br>Ctrl+Shift+Tab，转到上一个拆分器<br>【重构】<br>Ctrl+Alt+Shift+T，弹出重构菜单<br>Shift+F6，重命名<br>F6，移动<br>F5，复制<br>Alt+Delete，安全删除<br>Ctrl+Alt+N，内联<br>【查找】<br>Ctrl+F，查找<br>Ctrl+R，替换<br>F3，查找下一个<br>Shift+F3，查找上一个<br>Ctrl+Shift+F，在路径中查找<br>Ctrl+Shift+R，在路径中替换<br>Ctrl+Shift+S，搜索结构<br>Ctrl+Shift+M，替换结构<br>Alt+F7，查找用法<br>Ctrl+Alt+F7，显示用法<br>Ctrl+F7，在文件中查找用法<br>Ctrl+Shift+F7，在文件中高亮显示用法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ctrl+Shift + Enter，语句完成&lt;br&gt;“！”，否定完成，输入表达式时按 “！”键&lt;br&gt;Ctrl+E，最近的文件&lt;br&gt;Ctrl+Shift+E，最近更改的文件&lt;br&gt;Shift+Click，可以关闭文件&lt;br&gt;Ctrl+[ OR ]，可以跑到大括号的开头与
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>常用的正则表达式</title>
    <link href="http://yoursite.com/2020/04/29/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/04/29/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-04-29T08:47:31.000Z</published>
    <updated>2020-04-29T08:49:51.152Z</updated>
    
    <content type="html"><![CDATA[<p>特殊需求表达式：</p><ol><li><p>Email地址：^\w+([-+.]\w+)<em>@\w+([-.]\w+)*.\w+([-.]\w+)</em>$</p></li><li><p>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</p></li><li><p>InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$</p></li><li><p>手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</p></li><li><p>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$</p></li><li><p>国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}</p></li><li><p>身份证号(15位、18位数字)：^\d{15}|\d{18}$</p></li><li><p>短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</p></li><li><p>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</p></li><li><p>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$</p></li><li><p>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.<em>\d)(?=.</em>[a-z])(?=.*[A-Z]).{8,10}$</p></li><li><p>日期格式：^\d{4}-\d{1,2}-\d{1,2}</p></li><li><p>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</p></li><li><p>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</p></li><li><p>钱的输入格式：</p></li></ol><p>16.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$</p><ol start="17"><li><p>这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$</p></li><li><p>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$</p></li><li><p>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</p></li><li><p>必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$</p></li><li><p>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$</p></li><li><p>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</p></li></ol><p>23 .1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</p><ol start="24"><li><p>备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</p></li><li><p>xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$</p></li><li><p>中文字符的正则表达式：[\u4e00-\u9fa5]</p></li><li><p>双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</p></li><li><p>空白行的正则表达式：\n\s*\r (可以用来删除空白行)</p></li><li><p>HTML标记的正则表达式：&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?&lt;/\1&gt;|&lt;.</em>? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</p></li><li><p>首尾空白字符的正则表达式：^\s<em>|\s</em>$或(^\s<em>)|(\s</em>$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</p></li><li><p>腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)</p></li><li><p>中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)</p></li><li><p>IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用)</p></li><li><p>IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))</p></li></ol><p>二、校验字符的表达式</p><ol><li><p>汉字：^[\u4e00-\u9fa5]{0,}$</p></li><li><p>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</p></li><li><p>长度为3-20的所有字符：^.{3,20}$</p></li><li><p>由26个英文字母组成的字符串：^[A-Za-z]+$</p></li><li><p>由26个大写英文字母组成的字符串：^[A-Z]+$</p></li><li><p>由26个小写英文字母组成的字符串：^[a-z]+$</p></li><li><p>由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</p></li><li><p>由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$</p></li><li><p>中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</p></li><li><p>中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</p></li><li><p>可以输入含有^%&amp;’,;=?$&quot;等字符：[^%&amp;’,;=?$\x22]+ 12 禁止输入含有<del>的字符：[^</del>\x22]+</p></li></ol><p>一、校验数字的表达式</p><ol><li><p>数字：^[0-9]*$</p></li><li><p>n位的数字：^\d{n}$</p></li><li><p>至少n位的数字：^\d{n,}$</p></li><li><p>m-n位的数字：^\d{m,n}$</p></li><li><p>零和非零开头的数字：^(0|[1-9][0-9]*)$</p></li><li><p>非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$</p></li><li><p>带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$</p></li><li><p>正数、负数、和小数：^(-|+)?\d+(.\d+)?$</p></li><li><p>有两位小数的正实数：^[0-9]+(.[0-9]{2})?$</p></li><li><p>有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$</p></li><li><p>非零的正整数：^[1-9]\d<em>$ 或 ^([1-9][0-9]</em>){1,3}$ 或 ^+?[1-9][0-9]*$</p></li><li><p>非零的负整数：^-[1-9][]0-9”<em>$ 或 ^-[1-9]\d</em>$</p></li><li><p>非负整数：^\d+$ 或 ^[1-9]\d*|0$</p></li><li><p>非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</p></li><li><p>非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>|0?.0+|0$</p></li><li><p>非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>))|0?.0+|0$</p></li><li><p>正浮点数：^[1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>$ 或 ^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]*.[0-9]+)|([0-9]</em>[1-9][0-9]*))$</p></li><li><p>负浮点数：^-([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>)$ 或 ^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]*.[0-9]+)|([0-9]</em>[1-9][0-9]*)))$</p></li><li><p>浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>|0?.0+|0)$</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;特殊需求表达式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Email地址：^\w+([-+.]\w+)&lt;em&gt;@\w+([-.]\w+)*.\w+([-.]\w+)&lt;/em&gt;$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Ajax异步请求</title>
    <link href="http://yoursite.com/2020/04/29/Ajax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2020/04/29/Ajax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/</id>
    <published>2020-04-29T08:21:23.000Z</published>
    <updated>2020-04-29T08:30:07.430Z</updated>
    
    <content type="html"><![CDATA[<p>Ajax  </p><p>ajax:异步js和xml  异步刷新：如果网页中某一个地方需要修改，异步刷新可以使：只刷新该需要修改的地方</p><h5 id="一、使用原生JS方式实现ajax"><a href="#一、使用原生JS方式实现ajax" class="headerlink" title="一、使用原生JS方式实现ajax"></a>一、使用原生JS方式实现ajax</h5><pre><code>JS: XMLHttpRequest对象       </code></pre><p>​        XMLHttpRequest对象的方法：       </p><p>​        open(</p><p>​                方法名(提交方式get\post)，</p><p>​                服务器地址，true):与服务端建立连接·      </p><p>​                 send() :          </p><p>​                 get:send(null)           </p><p>​                post:send(参数值)       </p><p>​                setRequestHeader(header,value):           </p><p>​                get:不需要设置此方法          </p><p>​                post：需要设置                   </p><p>a.如果请求元素中包含了文件上传：setRequestHeader(“Content-Type”,”multiparty-form-data”)                   </p><p>b.不包含文件上传 ： setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”)             XMLHttpRequest对象的属性：readystate:请求状态   只有状态为4，才把响应执行完毕           </p><p> status:响应状态       只有200代表响应正常    </p><p> onreadystatechange:回调函数          </p><p> responseText：响应格式为String           </p><p> responseXML：响应为XML</p><h4 id="jquery-推荐"><a href="#jquery-推荐" class="headerlink" title="jquery:推荐"></a>jquery:推荐</h4><p>首先要使用ajax强推的就是利用jquery方式来实现，下面我为大家提供了几种方式</p><p>1.用ajax方法实现</p><p>$.ajax({     </p><p>​                utl:服务器地址，     </p><p>​                请求方式：get\post，     </p><p>​                data:请求数据，     </p><p>​                success:function(result,testStatus){</p><p>​                 },     error:function(xhr,erroeMessage,e){<br>​                         }   </p><p>​        }) </p><p>2.用get方法实现，比较简便，且只能处理get请求</p><p>​     $.get(     </p><p>​            服务器地址，     </p><p>​            请求数据，    </p><p>​           function(result){</p><p>​          }         </p><p>​        预期返回值类型（string\xml）   </p><p>​    )</p><p>3.利用post方法，同上 且只能处理post请求</p><p>$.post(     </p><p>​    服务器地址，     </p><p>​    请求数据，     </p><p>​    function(result){<br>​     }     </p><p>​    预期返回值类型（string\xml） </p><p>  )</p><p>4.利用load方式来实现，通过名字我们可以看出来这种方式是通过页面加载完毕后才可以执行，并且它需要依靠一个选择器，这个选择器可以是一个事件。</p><p>  $(“选择器”).load(    </p><p>​         服务器地址，      </p><p>​        请求数据，     </p><p>​         function(result){<br>​      }      预期返回值类型（string\xml）  </p><p> ) </p><p>​     load:将服务端的返回值 直接加载到$(“#xx”)所选择的元素中</p><p>5.这种方式只能处理JSON数据</p><p>  $.getJSON(       </p><p>​        服务器地址,       </p><p>​        JSON格式的请求数据，       </p><p>​        function(){}   </p><p>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ajax  &lt;/p&gt;
&lt;p&gt;ajax:异步js和xml  异步刷新：如果网页中某一个地方需要修改，异步刷新可以使：只刷新该需要修改的地方&lt;/p&gt;
&lt;h5 id=&quot;一、使用原生JS方式实现ajax&quot;&gt;&lt;a href=&quot;#一、使用原生JS方式实现ajax&quot; class=&quot;hea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring Boot注解大全</title>
    <link href="http://yoursite.com/2020/04/29/Spring-Boot%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2020/04/29/Spring-Boot%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/</id>
    <published>2020-04-29T08:08:52.000Z</published>
    <updated>2020-04-29T08:14:55.036Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、注解(annotations)列表</strong></p><p><strong>@SpringBootApplication</strong>：</p><p>包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。</p><p>其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。</p><p><strong>@Configuration</strong> 等同于spring的XML配置文件；使用Java代码可以检查类型安全。</p><p><strong>@EnableAutoConfiguration</strong> 自动配置。</p><p><strong>@ComponentScan</strong> 组件扫描，可自动发现和装配一些Bean。</p><p><strong>@Component</strong>可配合CommandLineRunner使用，在程序启动后执行一些基础任务。</p><p><strong>@RestController</strong>注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。</p><p><strong>@Autowired</strong>自动导入。</p><p><strong>@PathVariable</strong>获取参数。</p><p><strong>@JsonBackReference</strong>解决嵌套外链问题。</p><p><strong>@RepositoryRestResourcepublic</strong>配合spring-boot-starter-data-rest使用。</p><h1 id="二、注解-annotations-详解"><a href="#二、注解-annotations-详解" class="headerlink" title="二、注解(annotations)详解"></a>二、注解(annotations)详解</h1><p><strong>@SpringBootApplication</strong>：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myproject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// same as @Configuration @EnableAutoConfiguration @ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@ResponseBoby</strong>:表示该方法的返回结果直接写入到页面body当中，一般一部获取数据时使用、用于构建restful的api。</p><p>在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。</p><p>比如异步获取json数据，加上@responsebody后，会直接返回json数据。</p><p>该注解一般会配合@RequestMapping一起使用。示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(“/hello”)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>”hello”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Controller</strong>：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层）</p><p>一般这个注解在类中，通常方法需要配合注解@RequestMapping。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(“/cont”)</span><br><span class="line">publicclass ControllerTest &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoInfoService demoInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Map map)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DemoController.hello()"</span>);</span><br><span class="line">        map.put(<span class="string">"hello"</span>,<span class="string">"from TemplateController.helloHtml"</span>);</span><br><span class="line">        <span class="comment">//会使用hello.html或者hello.ftl模板进行渲染显示.</span></span><br><span class="line">        <span class="keyword">return</span><span class="string">"/hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@RestController</strong>：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kfit.demo.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(“/demoInfo2”)</span><br><span class="line">publicclass DemoController2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@RequestMapping</strong>：提供路由信息，负责URL到Controller中的具体函数的映射。</p><p><strong>@EnableAutoConfiguration</strong>：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。</p><p>例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。</p><p>你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。</p><p>如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。</p><p><strong>@ComponentScan</strong>：表示将该类自动发现扫描组件。</p><p>个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。</p><p>我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。</p><p>如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。</p><p><strong>@Configuration</strong>：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p><p><strong>@Import</strong>：用来导入其他配置类。</p><p><strong>@ImportResource</strong>：用来加载xml配置文件。</p><p><strong>@Autowired</strong>：自动导入依赖的bean</p><p><strong>@Service</strong>：一般用于修饰service层的组件</p><p><strong>@Repository</strong>：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p><p><strong>@Bean</strong>：用@Bean标注方法等价于XML中配置的bean。</p><p><strong>@Value</strong>：注入Spring boot application.properties配置的属性的值。示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(value = “#&#123;message&#125;”)</span><br><span class="line"><span class="keyword">private</span> String message;</span><br></pre></td></tr></table></figure><p><strong>@Inject</strong>：等价于默认的@Autowired，只是没有required属性；</p><p><strong>@Component</strong>：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p><strong>@Bean</strong>：相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p><p><strong>@AutoWired</strong>：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。</p><p><strong>@Qualifier</strong>：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value = “demoInfoService”)</span><br><span class="line"><span class="keyword">private</span> DemoInfoService demoInfoService;</span><br></pre></td></tr></table></figure><p><strong>@Resource</strong>(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。</p><h1 id="三、springMVC相关注解"><a href="#三、springMVC相关注解" class="headerlink" title="三、springMVC相关注解"></a>三、springMVC相关注解</h1><p><strong>@RequestMapping</strong>：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。</p><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。</p><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：</p><p><strong>params</strong>:指定request中必须包含某些参数值是，才让该方法处理。</p><p><strong>headers</strong>:指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p><strong>value</strong>:指定请求的实际地址，指定的地址可以是URI Template 模式</p><p><strong>method</strong>:指定请求的method类型， GET、POST、PUT、DELETE等</p><p><strong>consumes</strong>:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;</p><p><strong>produces</strong>:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p><p><strong>@RequestParam</strong>：用在方法的参数前面。<br>@RequestParam<br>String a =request.getParameter(“a”)。</p><p><strong>@PathVariable</strong>:路径变量。如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(“user/get/mac/&#123;macAddress&#125;”)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getByMacAddress</span><span class="params">(@PathVariable String macAddress)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数与大括号里的名字一样要相同。</p><h1 id="四、全局异常处理"><a href="#四、全局异常处理" class="headerlink" title="四、全局异常处理"></a>四、全局异常处理</h1><p><strong>@ControllerAdvice</strong>：包含@Component。可以被扫描到。统一处理异常。</p><p><strong>@ExceptionHandler</strong>（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、注解(annotations)列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@SpringBootApplication&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;包含了@ComponentScan、@Configuration和@EnableAutoC
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java I/O详解</title>
    <link href="http://yoursite.com/2020/04/26/Java-I-O%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/04/26/Java-I-O%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-26T03:18:06.000Z</published>
    <updated>2020-04-26T03:44:19.556Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是IO流"><a href="#什么是IO流" class="headerlink" title="什么是IO流?"></a>什么是IO流?</h3><p>IO流正是所谓的文件输入输出流，这是Java提供给我们开发者遍历的操作文件的技术。</p><p>文件可认为是相关记录或放在一起的数据的集合 </p><h4 id="file类的常用方法"><a href="#file类的常用方法" class="headerlink" title="file类的常用方法"></a>file类的常用方法</h4><p>​        方法名称          说   明 </p><p>​        boolean exists( )       判断文件或目录是否存在</p><p>​        boolean isFile( )       判断是否是文件</p><p>​        boolean isDirectory( )    判断是否是目录 </p><p>​        String getPath( )       返回此对象表示的文件的相对路径名 </p><p>​        String getAbsolutePath( )   返回此对象表示的文件的绝对路径名</p><p>​        String getName( )      返回此对象表示的文件或目录的名称</p><p>​        boolean delete( )      删除此对象指定的文件或目录 </p><p>​        boolean createNewFile( )   创建名称的空文件，不创建文件夹</p><p>​        long  length()       返回文件的长度，单位为字节, 如果文 件不存在，则返回 0L </p><h3 id="Java的流"><a href="#Java的流" class="headerlink" title="Java的流"></a>Java的流</h3><p>​        流是指一连串流动的字符，是以先进先出的方式发送和接受数据的通道</p><p>​        输入流：InputStream 只能从中读取数据，而不能向其中写入数据</p><p>​        输出流：OutputStream只能向其中写入数据，而不能向其中读取数据</p><p>​        按照流向区分：</p><p>​            输入流：InputStream和Reader作为基类</p><p>​            输出流：OutputStream和Writer作为基类</p><p>​        按照处理数据单元划分：</p><p>​            字节流：字节输入流InputStream基类</p><p>​            字节输出流OutputStream基类</p><p>​        字符流：字符输入流Reader基类</p><p>​        字符输出流Writer基类</p><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>文本文件的读写：</p><pre><code>用FileInputStream和FileOutputStream读写文本 文件 </code></pre><p>​            用BufferedReader和BufferedWriter读写文本文 件</p><p>二进制文件的读写：</p><p>​            使用DataInputStream和DataOutputStream读写 二进制文件</p><h3 id="InputStream常用方法"><a href="#InputStream常用方法" class="headerlink" title="InputStream常用方法"></a>InputStream常用方法</h3><p>​         int read( )   int read(byte[] b)  int read(byte[] b,int off,int len) uvoid close( )   int available()  子类    FileInputStream</p><h3 id="常用的构造方法"><a href="#常用的构造方法" class="headerlink" title="常用的构造方法"></a>常用的构造方法</h3><pre><code>FileInputStream(File file)    FileInputStream(String name)</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>​        前两种构造方法在向文件写数据时将覆盖文件中原有的内容 </p><p>2、创建FileOutputStream实例时，如果相应的文件并不存在， 则会自动创建一个空的文件</p><h3 id="BufferedReader类特有的方法"><a href="#BufferedReader类特有的方法" class="headerlink" title="BufferedReader类特有的方法"></a>BufferedReader类特有的方法</h3><p>​        BufferedReader类是Reader类的子类 BufferedReader类带有缓冲区 按行读取内容的readLine()方法</p><p><img src="img/io.png" alt="io"></p><p>这个是IO流关系图，可以方便大家更好的理解IO流</p><h3 id="读取二进制文件"><a href="#读取二进制文件" class="headerlink" title="读取二进制文件"></a>读取二进制文件</h3><p>​        DataInputStream类</p><p>​         FileInputStream的子类 </p><p>​        与FileInputStream类结合使用读取二进制文件 </p><p>​         DataOutputStream类</p><p>​         FileOutputStream的子类 </p><p>​        与FileOutputStream类结合使用写二进制文件</p><h3 id="使用文件流的步骤"><a href="#使用文件流的步骤" class="headerlink" title="使用文件流的步骤"></a>使用文件流的步骤</h3><p>引入相关的类</p><p>创建输入流/l输出流对象</p><p> 读取/写入文本文件的数据</p><p>关闭相关的流对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是IO流&quot;&gt;&lt;a href=&quot;#什么是IO流&quot; class=&quot;headerlink&quot; title=&quot;什么是IO流?&quot;&gt;&lt;/a&gt;什么是IO流?&lt;/h3&gt;&lt;p&gt;IO流正是所谓的文件输入输出流，这是Java提供给我们开发者遍历的操作文件的技术。&lt;/p&gt;
&lt;p&gt;文件可
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何快速的学习一门语言</title>
    <link href="http://yoursite.com/2020/04/24/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2020/04/24/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E8%AF%AD%E8%A8%80/</id>
    <published>2020-04-24T05:32:37.000Z</published>
    <updated>2020-04-25T05:58:47.914Z</updated>
    
    <content type="html"><![CDATA[<p>​        首先,在我们学习新东西的时候我们会产生好奇的心态，我们会问这个东西是干什么的? 我学这个东西有什么用？这些都是我们常见的一些问题，这里我们就用Java来举例，那么必须要知道的是我们为什么要学习Java，学习Java能给我带来什么好处，在学习一门新的语言之前，一定要了解自己为什么要学习它，了解清楚Java是干什么的，当你真正了解一门语言，你就会有清晰的目标。</p><h3 id="我该如何学习"><a href="#我该如何学习" class="headerlink" title="我该如何学习?"></a>我该如何学习?</h3><p>​     首先，这些学习方式以及经验都是我个人总结出来的，没有任何抄袭现象，很多东西都是有一些大众化，我尽量帮助各位小伙伴解疑答惑。</p><p>​        论学习，唯独一个字，从小学到大学一直没有变的一个字:”练”,只要练不死，就往死里练，其次就是要学会理解，在适当的时间专门钻研一个东西，当然是要钻研重要的东西。大家可能有的是自学，有的是报的培训班，但是这些都没有关系，我们都是在学习，不论在哪里。</p><h5 id="1-学习中遇到问题怎么办"><a href="#1-学习中遇到问题怎么办" class="headerlink" title="1.学习中遇到问题怎么办?"></a>1.学习中遇到问题怎么办?</h5><p>​    遇到问题不要慌，都是很正常的现象，在这里我可以跟大家分享一下我的经历，学过的小伙伴们也都知道，我们会碰到各式各样的bug，我自己也是一样，记得有一次，遇到了一个比较罕见的bug我就去网上查阅各种资料看各种源码，最后发现也就是少了一个标点符号，哈哈。其实这些并不是丢人，能够发现自己的问题并解决就是能力。就像我说的，遇到问题，可以先去百度或者更Google上搜索一下，如果搜索不出来，可以尝试的问一些大牛们，在培训班的小伙伴可以问一些老师，当然，初学者遇到问题呢也可以直接来找我，我随时欢迎你们，记住，在学习中遇到问题是很正常的，并且你也一定要希望遇到问题，解决了你就能提升。</p><h5 id="2-不知道学什么怎么办"><a href="#2-不知道学什么怎么办" class="headerlink" title="2.不知道学什么怎么办?"></a>2.不知道学什么怎么办?</h5><p>​        在互联网行业，技术发展随之即快，所以我们一定要不停的学习，什么技术火，学习什么技术，记住一句话，我们为什么要学习它？因为用的人多，所以我们要学习。无论你是在学习中还是在工作中，千万不要停止学习的脚步，你可以关注一些公众号以及一些关于IT的网站，这里面都会去详细讲解新技术发展如何，我们又改学习什么，当然把基础的学会，其他入门就很容易。具体还要学什么，就看公司要求了。我这里后续也会推出，学习路线以及群里的学习资料，对了,这里打个广告哈哈，这个是我自行创的群目前还没什么人，当然我也是希望你们能够加入和我一起进步:1081931475</p><h5 id="3-行业发展这么快-我赶不上怎么办"><a href="#3-行业发展这么快-我赶不上怎么办" class="headerlink" title="3.行业发展这么快?我赶不上怎么办?"></a>3.行业发展这么快?我赶不上怎么办?</h5><p>​        这个问题其实没有任何的确定回复性，因为现实就是如此，适者生存，如果你没有足够的能力在社会上立足，那么就会有人取代你。所以要想发展，必须做出努力。学习是我们最好的出路，无论到哪里，学习永远不会使人退步。</p><p>下面我为大家展现出第一个Java程序，当然第一个Java程序是非常简单的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJava</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信大佬们闭着眼睛都能写出来，但是初学者们，你们是否感觉到难了呢，因为你们没有接触过，当你们接触的时候你们就会豁然开朗，发现程序竟然是这么的好玩，很多事情开头都是一头污水 ，所以不要看着这么多英语，就放弃学习了，你自己选择的路一定要走下去。</p><h5 id="4-数学和英语不好能学会吗"><a href="#4-数学和英语不好能学会吗" class="headerlink" title="4.数学和英语不好能学会吗?"></a>4.数学和英语不好能学会吗?</h5><p>​        相信这个问题在很多初学者面前一直是一个大问题，我们没有好的数学和英语水平，但我可以告诉你们，我的数学和英语也是一塌糊度，但尽管没有这些做基垫，我照样可以学的很好，可能数学好的小伙伴学习编程可能会好理解一些，但这些相差并不大，只要我们肯努力，学习起来是不难的，我也可以告诉你们，英语不好学习编程也没有问题，因为学习编程还会使你的逻辑思维和英语大幅提升。</p><p>死亡鸡汤 总结一句话：数学只要会+ - * / % 就可以  英语的话不会也没事，只要了解就行了</p><p><strong>还有最重要的一点:学习编程后，一定要魔鬼训练自己的打字速度，这个非常重要，还要练习盲打。</strong></p><h5 id="5-学过之后忘了怎么办？"><a href="#5-学过之后忘了怎么办？" class="headerlink" title="5.学过之后忘了怎么办？"></a>5.学过之后忘了怎么办？</h5><p>​    这里我提出三个解决办法:</p><p>​            1.学习的同时自己要记笔记，写代码注释，并要有自己的总结，没事拿出来看看。也要归纳一个文档。</p><p>​            2.反复的复习，忘记哪个技术，回过头再看一遍。</p><p>​            3.写技术博客，就像我这样，把一些技术写到博客里，这样就算你电脑的文件没了，这个博客也不会没。</p><p>好了这期就到这里，可以看出来，这是我第一篇文章，我希望大家有什么意见尽管提出来，你们的意见是我提升的目标，谢谢大家！！！</p><p>​        </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        首先,在我们学习新东西的时候我们会产生好奇的心态，我们会问这个东西是干什么的? 我学这个东西有什么用？这些都是我们常见的一些问题，这里我们就用Java来举例，那么必须要知道的是我们为什么要学习Java，学习Java能给我带来什么好处，在学习一门新的语言之前
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/04/23/hello-world/"/>
    <id>http://yoursite.com/2020/04/23/hello-world/</id>
    <published>2020-04-23T11:19:40.336Z</published>
    <updated>2020-04-25T05:10:26.825Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
